<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <style>@import url('https://fonts.googleapis.com/css?family=Roboto:300');

* {
  box-sizing: border-box;
  font-family: 'Roboto', sans-serif;
}

table {
  width: 100%;
  font-size: 14px;
  color: black;
}

thead {
  background-color: gray;
  color: white;
}

th,
td {
  border-style: solid;
  border-color: gray;
  border-width: 0 1px 1px 0;
  height: 50px;
  text-align: center;
}

a {
  width: 100%;
  height: 100%;
  display: block;
  text-align: center;
  padding-top: 15px;
  color: inherit;
  text-decoration: none;
  font-weight: bold;
}

a:hover {
  background-color: black;
  color: white;
}

select {
  width: 38%;
  height: 100%;
}

textarea {
  display: block;
  margin: 0 auto;
  width: 99%;
  height: 100%;
}

#notification-container {
  position: fixed;
  bottom: 0;
  right: 0;
  padding: 1rem;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 0.5rem;
  z-index: 1000;
  pointer-events: none;
}

.toast {
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 0.75rem 1.25rem;
  border-radius: 0.25rem;
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
  pointer-events: auto;
}

.toast.show {
  opacity: 1;
}</style>
    <title>ha.ze.gs</title>
  </head>
  <body>
    <table>
      <thead>
        <tr>
          <th>Switch</th>
          <th>
            <a
              href="http://a.ze.gs/hue/lights/off?url=http://ha.ze.gs"
              data-api='[["hue","lights","off"],["switchbot-command","-d","C70C0516C0C7","-c","turnOff"],["switchbot-command","-d","ECCC4C8C52C3","-c","turnOff"],["switchbot-ac","-d","02-202307290753-22894539","-a","25,2,1,off"],["switchbot-custom","-d","03-202401251013-58699638","-c","Off"]]'
              data-status-action="control"
              >Go Out</a
            >
          </th>
          <th>&nbsp;</th>
          <th>&nbsp;</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td id="Living">Living</td>
          <td><a href="http://a.ze.gs/switchbot-command/-d/C70C0516C0C7/-c/turnOn?url=http://ha.ze.gs" data-api='["switchbot-command", "-d", "C70C0516C0C7", "-c", "turnOn"]'>On</a></td>
          <td>&nbsp;</td>
          <td><a href="http://a.ze.gs/switchbot-command/-d/C70C0516C0C7/-c/turnOff?url=http://ha.ze.gs" data-api='["switchbot-command", "-d", "C70C0516C0C7", "-c", "turnOff"]'>Off</a></td>
        </tr>
        <tr>
          <td id="Dining">Dining</td>
          <td><a href="http://a.ze.gs/hue/lights/13,14,15,28,29/on?url=http://ha.ze.gs" data-api='["hue","lights","13,14,15,28,29","on"]'>On</a></td>
          <td>&nbsp;</td>
          <td><a href="http://a.ze.gs/hue/lights/13,14,15,28,29/off?url=http://ha.ze.gs" data-api='["hue","lights","13,14,15,28,29","off"]'>Off</a></td>
        </tr>
        <tr>
          <td id="Tatami">Tatami</td>
          <td><a href="http://a.ze.gs/switchbot-command/-d/ECCC4C8C52C3/-c/turnOn?url=http://ha.ze.gs" data-api='["switchbot-command","-d","ECCC4C8C52C3","-c","turnOn"]'>On</a></td>
          <td>&nbsp;</td>
          <td><a href="http://a.ze.gs/switchbot-command/-d/ECCC4C8C52C3/-c/turnOff?url=http://ha.ze.gs" data-api='["switchbot-command","-d","ECCC4C8C52C3","-c","turnOff"]'>Off</a></td>
        </tr>
        <tr>
          <td id="Downright">Down right</td>
          <td><a href="http://a.ze.gs/hue/lights/27/on?url=http://ha.ze.gs" data-api='["hue","lights","27","on"]'>On</a></td>
          <td>&nbsp;</td>
          <td><a href="http://a.ze.gs/hue/lights/27/off?url=http://ha.ze.gs" data-api='["hue","lights","27","off"]'>Off</a></td>
        </tr>
        <tr>
          <td id="Downleft">Down left</td>
          <td><a href="http://a.ze.gs/hue/lights/26/on?url=http://ha.ze.gs" data-api='["hue","lights","26","on"]'>On</a></td>
          <td>&nbsp;</td>
          <td><a href="http://a.ze.gs/hue/lights/26/off?url=http://ha.ze.gs" data-api='["hue","lights","26","off"]'>Off</a></td>
        </tr>
        <tr>
          <td id="Downback">Down back</td>
          <td><a href="http://a.ze.gs/hue/lights/7/on?url=http://ha.ze.gs" data-api='["hue","lights","7","on"]'>On</a></td>
          <td>&nbsp;</td>
          <td><a href="http://a.ze.gs/hue/lights/7/off?url=http://ha.ze.gs" data-api='["hue","lights","7","off"]'>Off</a></td>
        </tr>
        <tr>
          <td id="Washroom">Washroom</td>
          <td><a href="http://a.ze.gs/hue/lights/22/on?url=http://ha.ze.gs" data-api='["hue","lights","22","on"]'>On</a></td>
          <td>&nbsp;</td>
          <td><a href="http://a.ze.gs/hue/lights/22/off?url=http://ha.ze.gs" data-api='["hue","lights","22","off"]'>Off</a></td>
        </tr>
        <tr>
          <td id="Bathroom">Bathroom</td>
          <td><a href="http://a.ze.gs/hue/lights/8,9/on?url=http://ha.ze.gs" data-api='["hue","lights","8,9","on"]'>On</a></td>
          <td>&nbsp;</td>
          <td><a href="http://a.ze.gs/hue/lights/8,9/off?url=http://ha.ze.gs" data-api='["hue","lights","8,9","off"]'>Off</a></td>
        </tr>
        <tr>
          <td id="Corridor">Corridor</td>
          <td><a href="http://a.ze.gs/hue/lights/21,16/on?url=http://ha.ze.gs" data-api='["hue","lights","21,16","on"]'>On</a></td>
          <td>&nbsp;</td>
          <td><a href="http://a.ze.gs/hue/lights/21,16/off?url=http://ha.ze.gs" data-api='["hue","lights","21,16","off"]'>Off</a></td>
        </tr>
        <tr>
          <td id="Restroom">Restroom</td>
          <td><a href="http://a.ze.gs/hue/lights/10/on?url=http://ha.ze.gs" data-api='["hue","lights","10","on"]'>On</a></td>
          <td>&nbsp;</td>
          <td><a href="http://a.ze.gs/hue/lights/10/off?url=http://ha.ze.gs" data-api='["hue","lights","10","off"]'>Off</a></td>
        </tr>
        <tr>
          <td id="VoiceChange">Voice Change</td>
          <td>
            <a href="http://a.ze.gs/google-home-speaker-wrapper-change-voice/openai?url=http://ha.ze.gs" data-api='["google-home-speaker-wrapper-change-voice","openai"]'>OpenAI</a>
          </td>
          <td>&nbsp;</td>
          <td>
            <a href="http://a.ze.gs/google-home-speaker-wrapper-change-voice/gtts?url=http://ha.ze.gs" data-api='["google-home-speaker-wrapper-change-voice","gtts"]'>GTTS</a>
          </td>
        </tr>
        <tr>
          <td id="AC">
            <a href="#" data-status-action="control">A/C</a>
          </td>
          <td>
            <a
              href="http://a.ze.gs/switchbot-ac/-d/02-202307290753-22894539/-a/28,2,1,on?url=http://ha.ze.gs"
              data-api='["switchbot-ac","-d","02-202307290753-22894539","-a","28,2,1,on"]'
              data-status-action="cool"
              >Cool</a
            >
          </td>
          <td>
            <a
              href="http://a.ze.gs/switchbot-ac/-d/02-202307290753-22894539/-a/28,5,1,on?url=http://ha.ze.gs"
              data-api='["switchbot-ac","-d","02-202307290753-22894539","-a","28,5,1,on"]'
              data-status-action="hot"
              >Hot</a
            >
          </td>
          <td>
            <a
              href="http://a.ze.gs/switchbot-ac/-d/02-202307290753-22894539/-a/25,2,1,off?url=http://ha.ze.gs"
              data-api='["switchbot-ac","-d","02-202307290753-22894539","-a","25,2,1,off"]'
              data-status-action="off"
              >Off</a
            >
          </td>
        </tr>
        <tr>
          <td id="TatamiAC">Tatami A/C</td>
          <td><a href="http://a.ze.gs/switchbot-custom/-d/03-202401251013-58699638/-c/Cool?url=http://ha.ze.gs" data-api='["switchbot-custom","-d","03-202401251013-58699638","-c","Cool"]'>Cool</a></td>
          <td><a href="http://a.ze.gs/switchbot-custom/-d/03-202401251013-58699638/-c/Hot?url=http://ha.ze.gs" data-api='["switchbot-custom","-d","03-202401251013-58699638","-c","Hot"]'>Hot</a></td>
          <td><a href="http://a.ze.gs/switchbot-custom/-d/03-202401251013-58699638/-c/Off?url=http://ha.ze.gs" data-api='["switchbot-custom","-d","03-202401251013-58699638","-c","Off"]'>Off</a></td>
        </tr>
        <tr>
          <td>Tool</td>
          <td><a href="http://a.ze.gs/switchbot-command/-d/D23403D2D43D/-c/press?url=http://ha.ze.gs" data-api='["switchbot-command","-d","D23403D2D43D","-c","press"]'>HeatFloor</a></td>
          <td>&nbsp;</td>
          <td>
            <a
              href="http://a.ze.gs/google-home-speaker-wrapper/-h/192.168.1.22/-v/60/-s/%E3%83%81%E3%82%A8%E3%83%9F%E3%81%95%E3%82%93%E3%80%81%E3%83%9E%E3%83%9E%E3%81%95%E3%82%93%E3%80%81%E3%83%91%E3%83%91%E3%81%8C%E5%88%B0%E7%9D%80%E3%81%97%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82%E6%BA%96%E5%82%99%E3%82%92%E3%81%8A%E9%A1%98%E3%81%84%E3%81%97%E3%81%BE%E3%81%99%E3%80%82?url=http://ha.ze.gs"
              data-message-key="car-arrival"
              >CarArrives</a
            >
          </td>
        </tr>
        <tr>
          <td id="Fan">Fan</td>
          <td><a href="http://a.ze.gs/switchbot-command/-d/03-202401251013-89002900/-c/turnOn?url=http://ha.ze.gs" data-api='["switchbot-command","-d","03-202401251013-89002900","-c","turnOn"]'>On/Off</a></td>
          <td><a href="http://a.ze.gs/switchbot-command/-d/03-202401251013-89002900/-c/highSpeed?url=http://ha.ze.gs" data-api='["switchbot-command","-d","03-202401251013-89002900","-c","highSpeed"]'>Turbo</a></td>
          <td><a href="http://a.ze.gs/switchbot-command/-d/03-202401251013-89002900/-c/swing?url=http://ha.ze.gs" data-api='["switchbot-command","-d","03-202401251013-89002900","-c","swing"]'>Swing</a></td>
        </tr>
        <tr>
          <td id="NW">Nest WiFi</td>
          <td><a href="http://a.ze.gs/catt/-d/192.168.1.22/volumeup?url=http://ha.ze.gs" data-api='["catt","-d","host:nest","volumeup"]'>+</a></td>
          <td><a href="http://a.ze.gs/catt/-d/192.168.1.22/volumedown?url=http://ha.ze.gs" data-api='["catt","-d","host:nest","volumedown"]'>-</a></td>
          <td><a href="http://a.ze.gs/catt/-d/192.168.1.22/stop?url=http://ha.ze.gs" data-api='["catt","-d","host:nest","stop"]'>Off</a></td>
        </tr>
        <tr>
          <td id="TW">Tatami WiFi</td>
          <td><a href="http://a.ze.gs/catt/-d/192.168.1.236/volumeup?url=http://ha.ze.gs" data-api='["catt","-d","host:tatami","volumeup"]'>+</a></td>
          <td><a href="http://a.ze.gs/catt/-d/192.168.1.236/volumedown?url=http://ha.ze.gs" data-api='["catt","-d","host:tatami","volumedown"]'>-</a></td>
          <td><a href="http://a.ze.gs/catt/-d/192.168.1.236/stop?url=http://ha.ze.gs" data-api='["catt","-d","host:tatami","stop"]'>Off</a></td>
        </tr>
        <tr>
          <td id="CC">TV</td>
          <td><a href="http://a.ze.gs/catt/-d/192.168.1.219/volumeup?url=http://ha.ze.gs" data-api='["catt","-d","host:tv","volumeup"]'>+</a></td>
          <td><a href="http://a.ze.gs/catt/-d/192.168.1.219/volumedown?url=http://ha.ze.gs" data-api='["catt","-d","host:tv","volumedown"]'>-</a></td>
          <td><a href="http://a.ze.gs/catt/-d/192.168.1.219/stop?url=http://ha.ze.gs" data-api='["catt","-d","host:tv","stop"]'>Off</a></td>
        </tr>
        <tr>
          <td id="YouTube"><a href="#" data-youtube-key="tv" data-youtube-vol="20">YouTube</a></td>
          <td><textarea id="youtube_url"></textarea></td>
          <td><a href="#" data-youtube-key="nest">Nest Wifi</a></td>
          <td><a href="#" data-youtube-key="tatami">Tatami WiFi</a></td>
        </tr>
        <tr>
          <td id="Voice">Voice</td>
          <td><textarea id="voicetext"></textarea></td>
          <td><a id="speak" href="#">Nest Wifi</a></td>
          <td><a id="speak_tatami" href="#">Tatami WiFi</a></td>
        </tr>
        <tr>
          <td id="Alarm">Alarm</td>
          <td>
            <select id="hour"></select>
            :
            <select id="min"></select>
          </td>
          <td><textarea id="alarmtext"></textarea></td>
          <td><a id="set" href="#">Set</a></td>
        </tr>
        <tr>
          <td id="AirCondition">AirCondition</td>
          <td id="Date">&nbsp;</td>
          <td id="Temperature">&nbsp;</td>
          <td id="Humid">&nbsp;</td>
        </tr>
      </tbody>
    </table>

    <script>/**
 * @returns {{
 *   normalizeText: (value: unknown) => string,
 *   sanitizeText: (value: unknown) => string,
 *   getMaxEncodedLength: (maxText: unknown) => number,
 *   isTextTooLong: (value: unknown, maxText: unknown) => boolean
 * }}
 */
const createTextUtils = () => {
  const normalizeText = (value) => String(value ?? "").replace(/\s+/g, "　").trim();
  const sanitizeText = (value) => encodeURIComponent(normalizeText(value));
  const getMaxEncodedLength = (maxText) => encodeURIComponent(normalizeText(maxText)).length;
  const isTextTooLong = (value, maxText) =>
    encodeURIComponent(normalizeText(value)).length > getMaxEncodedLength(maxText);

  return {
    normalizeText,
    sanitizeText,
    getMaxEncodedLength,
    isTextTooLong,
  };
};

const defaultTextUtils = createTextUtils();

const { normalizeText, sanitizeText, getMaxEncodedLength, isTextTooLong } = defaultTextUtils;

const DATA_API_DELAY_MS = 200;
const NOTIFY_DEBOUNCE_MS = 2 * 1000;
const NOTIFY_DURATION_MS = 5 * 1000;
const STATUS_INTERVAL_MS = 10 * 60 * 1000;
const STATUS_BACKOFF_MS = 60 * 1000;
const MAX_TEXT =
  "１２３４５６７８９０１２３４５６７８９０１２３４５６７８９０１２３４５６７８９０１２３４５６７８９０１２３４５６７８９０１２３４５６７８９０１２３４５６７８９０１２３４５６７８９０１２３4";

const ALARM_SCRIPT_URL =
  "https://script.google.com/macros/s/AKfycbyGtgeNC_rHFxPvSj7XjO5GdM6awoqlxJ7PDmfcadghjZshQ8Y/exec";

const API_BASE_URL = "http://a.ze.gs";

const DEVICE_HOSTS = {
  nest: "192.168.1.22",
  tatami: "192.168.1.236",
  tv: "192.168.1.219",
};

const STATUS_SCRIPT_URL =
  "https://script.google.com/macros/s/AKfycbz61Wl_rfwYOuZ0z2z9qeegnIsanQeu6oI3Q3K5gX66Hgroaoz2z466ck9xMSvBfHpwUQ/exec";
const STATUS_CALLBACK = "__statusCallback";
const STATUS_KEYS = ["AirCondition", "Date", "Temperature", "Humid"];

const VOICE_HOSTS = { speak: DEVICE_HOSTS.nest, speakTatami: DEVICE_HOSTS.tatami };
const CAR_ARRIVAL_MESSAGE = "チエミさん、ママさん、パパが到着しました。準備をお願いします。";

const YOUTUBE_HOSTS = new Set(["youtube.com", "www.youtube.com", "m.youtube.com", "music.youtube.com"]);

const ERROR_MESSAGES = {
  FETCH_STATUS: "Failed to fetch latest status",
  EXEC_COMMANDS: "Failed to execute data-api commands",
  SEND_VOICE: "Failed to send voice command",
  PARSE_DATA_API: "Failed to parse data-api payload",
  INVALID_DATA_API: "Invalid data-api payload",
  MISSING_CONDITIONS: "Missing status conditions",
  FETCH_PAYLOAD: "Failed to fetch status payload",
  INVALID_URL: "Invalid URL",
  TOO_LONG: "Too long text",
};

/**
 * @param {{ apiBaseUrl?: string, deviceHosts?: Record<string, string> }} [options]
 * @returns {{
 *   apiUrl: (args: Array<string | number>) => string,
 *   resolveHost: (value: string) => string,
 *   replaceHostTokens: (args: Array<string | number>) => Array<string | number>
 * }}
 */
const createHostResolver = ({ apiBaseUrl = API_BASE_URL, deviceHosts = DEVICE_HOSTS } = {}) => {
  const apiUrl = (args) => `${apiBaseUrl}/${args.map(String).join("/")}`;
  const resolveHost = (value) => deviceHosts[value] ?? value;
  const replaceHostTokens = (args) =>
    args.map((arg) => (typeof arg === "string" && arg.startsWith("host:") ? resolveHost(arg.slice(5)) : arg));

  return {
    apiUrl,
    resolveHost,
    replaceHostTokens,
  };
};

const defaultResolver = createHostResolver();

const { apiUrl, resolveHost, replaceHostTokens } = defaultResolver;

const DEFAULT_OPTIONS = {
  containerId: "notification-container",
  debounceMs: NOTIFY_DEBOUNCE_MS,
  durationMs: NOTIFY_DURATION_MS,
  showDelayMs: 10,
  transitionMs: 300,
};

const cache = new WeakMap();
const messageText = (message) => String(message ?? "");

/**
 * @param {Document} doc
 * @param {{
 *   containerId?: string,
 *   debounceMs?: number,
 *   durationMs?: number,
 *   showDelayMs?: number,
 *   transitionMs?: number
 * }} [options]
 * @returns {{ notify: (message: unknown) => void }}
 */
const createNotifier = (doc, options = {}) => {
  const settings = { ...DEFAULT_OPTIONS, ...options };
  let lastMessage = "";
  let timer;
  const notify = (message) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      lastMessage = "";
    }, settings.debounceMs);
    const text = messageText(message);
    if (text === lastMessage) return;
    lastMessage = text;
    const container = doc?.getElementById?.(settings.containerId);
    if (!container || container.isConnected === false) return;
    const toast = doc.createElement("div");
    toast.className = "toast";
    toast.textContent = text;
    container.appendChild(toast);
    setTimeout(() => toast.classList.add("show"), settings.showDelayMs);
    setTimeout(() => {
      toast.classList.remove("show");
      setTimeout(() => toast.remove(), settings.transitionMs);
    }, settings.durationMs);
  };
  return { notify };
};

/**
 * @param {Document} doc
 * @param {unknown} message
 */
const notify = (doc, message) => {
  if (!doc) return;
  const notifier = cache.get(doc) ?? createNotifier(doc);
  cache.set(doc, notifier);
  notifier.notify(message);
};

/**
 * @param {Document} doc
 * @param {string} message
 * @param {unknown} [details]
 */
const reportError = (doc, message, details) => {
  details === undefined ? console.error(message) : console.error(message, details);
  notify(doc, message);
};

/**
 * @param {string} hour
 * @param {string} minute
 * @param {string} text
 * @returns {string | null}
 */
const buildAlarmUrl = (hour, minute, text) => {
  if (isTextTooLong(text, MAX_TEXT)) return null;
  const sanitized = sanitizeText(text);
  return `${ALARM_SCRIPT_URL}?time=${hour}:${minute}:00&text=${sanitized}`;
};

const padTime = (value) => String(value).padStart(2, "0");
const buildTimeOptions = (count) =>
  Array.from({ length: count }, (_, index) => {
    const value = padTime(index);
    return `<option value="${value}">${value}</option>`;
  }).join("");

/**
 * @param {HTMLSelectElement} hourSelect
 * @param {HTMLSelectElement} minuteSelect
 * @param {Date} [now]
 */
const setAlarmDefaults = (hourSelect, minuteSelect, now = new Date()) => {
  if (!hourSelect.options.length) hourSelect.innerHTML = buildTimeOptions(24);
  if (!minuteSelect.options.length) minuteSelect.innerHTML = buildTimeOptions(60);
  const setIfExists = (select, value) => select.querySelector(`option[value="${value}"]`) && (select.value = value);
  setIfExists(hourSelect, padTime(now.getHours()));
  setIfExists(minuteSelect, padTime(now.getMinutes()));
};

/**
 * @param {{
 *   doc: Document,
 *   fetcher: typeof fetch,
 *   notifier?: { reportError?: (doc: Document, message: string, details?: unknown) => void },
 *   elements: { hour: HTMLSelectElement, min: HTMLSelectElement, alarmtext: HTMLInputElement },
 *   buildAlarmUrl?: (hour: string, minute: string, text: string) => string | null
 * }} params
 */
const createAlarmController = ({
  doc,
  fetcher,
  notifier,
  elements,
  buildAlarmUrl: buildAlarmUrlFn = buildAlarmUrl,
} = {}) => {
  const setDefaults = () => setAlarmDefaults(elements.hour, elements.min);
  const setAlarm = async () => {
    const alarmUrl = buildAlarmUrlFn(elements.hour.value, elements.min.value, elements.alarmtext.value);
    if (!alarmUrl) {
      notifier?.reportError?.(doc, ERROR_MESSAGES.TOO_LONG, elements.alarmtext.value);
      return false;
    }
    await fetcher(alarmUrl);
    return true;
  };
  return { setDefaults, setAlarm };
};

/**
 * @param {{
 *   statusScriptUrl?: string,
 *   statusCallback?: string,
 *   statusKeys?: Array<string>,
 *   reportError?: (doc: Document, message: string, details?: unknown) => void
 * }} [options]
 * @returns {{
 *   buildStatusUrl: (params?: Record<string, string>) => string,
 *   parseLatestPayload: (doc: Document, payload: string) => Record<string, unknown> | null,
 *   fetchLatestStatus: (doc: Document, fetcher: typeof fetch, options?: { signal?: AbortSignal }) => Promise<Record<string, unknown> | null>,
 *   updateStatusCells: (latest: Record<string, unknown>, elements: Record<string, HTMLElement>) => void,
 *   statusCellKeys: Array<string>
 * }}
 */
const createStatusService = ({
  statusScriptUrl = STATUS_SCRIPT_URL,
  statusCallback = STATUS_CALLBACK,
  statusKeys = STATUS_KEYS,
  reportError: reportErrorFn = reportError,
} = {}) => {
  const buildStatusUrl = (params = {}) => `${statusScriptUrl}?${new URLSearchParams(params)}`;

  const stripStatusCallback = (value) =>
    value
      .replace(new RegExp(`^${statusCallback}(?:&&${statusCallback})?\\(`), "")
      .replace(/\);?\s*$/, "");

  const normalizePayload = (payload) => {
    const trimmed = payload.trim();
    if (!trimmed) return "";
    return /^[{[]/.test(trimmed) ? trimmed : stripStatusCallback(trimmed).trim();
  };

  const parseConditions = (doc, payload) => {
    try {
      const { conditions, status } = JSON.parse(payload);
      if (!Array.isArray(conditions) || !conditions.length) {
        reportErrorFn(doc, ERROR_MESSAGES.MISSING_CONDITIONS, {
          hasConditions: Array.isArray(conditions),
          length: Array.isArray(conditions) ? conditions.length : null,
        });
        return null;
      }
      const latest = conditions.at(-1);
      return latest ? (status === undefined ? latest : { ...latest, AirCondition: status }) : null;
    } catch (error) {
      reportErrorFn(doc, ERROR_MESSAGES.FETCH_PAYLOAD, {
        cleanedPreview: payload.length > 200 ? `${payload.slice(0, 200)}…` : payload,
        cleanedLength: payload.length,
        error,
      });
      return null;
    }
  };

  const parseLatestPayload = (doc, payload) => {
    const cleaned = normalizePayload(payload);
    if (!cleaned) {
      reportErrorFn(doc, ERROR_MESSAGES.FETCH_PAYLOAD, {
        cleanedPreview: "",
        cleanedLength: 0,
        error: new Error("Empty payload"),
      });
      return null;
    }
    return parseConditions(doc, cleaned);
  };

  const fetchLatestStatus = async (doc, fetcher, { signal } = {}) => {
    const url = buildStatusUrl({ callback: statusCallback });
    const response = await (signal ? fetcher(url, { signal }) : fetcher(url));
    const payload = await response.text();
    if (!response.ok) {
      reportErrorFn(doc, ERROR_MESSAGES.FETCH_PAYLOAD, {
        status: response.status,
        statusText: response.statusText,
        preview: payload.slice(0, 200),
      });
    }
    return parseLatestPayload(doc, payload);
  };

  const formatDateTimeLocal = (value) => {
    const parsed = new Date(value);
    return Number.isNaN(parsed.getTime())
      ? value
      : new Intl.DateTimeFormat("en-US", {
          month: "short",
          day: "numeric",
          hour: "2-digit",
          minute: "2-digit",
          hour12: false,
        })
          .format(parsed)
          .replace(",", "");
  };

  const updateStatusCells = (latest, elements) => {
    if (!latest || typeof latest !== "object") return;
    statusKeys.forEach((key) => {
      const value = latest[key];
      if (key === "AirCondition") return void (elements[key].innerText = value == null ? "AirCondition" : String(value));
      if (key === "Date") return void (elements[key].innerText = formatDateTimeLocal(value));
      elements[key].innerText = key === "Temperature" ? `${value}C` : `${value}%`;
    });
  };

  return {
    buildStatusUrl,
    parseLatestPayload,
    fetchLatestStatus,
    updateStatusCells,
    statusCellKeys: statusKeys,
  };
};

const defaultStatusService = createStatusService();

const { buildStatusUrl, parseLatestPayload, fetchLatestStatus, updateStatusCells } = defaultStatusService;

/**
 * @param {{
 *   doc: Document,
 *   fetcher: typeof fetch,
 *   statusCells: Record<string, HTMLElement>,
 *   hasStatus?: boolean,
 *   statusService?: ReturnType<typeof createStatusService>
 * }} params
 */
const createStatusController = ({
  doc,
  fetcher,
  statusCells,
  hasStatus = true,
  statusService = defaultStatusService,
} = {}) => {
  const fetchLatest = async (signal) => {
    if (!hasStatus) return null;
    const latest = await statusService.fetchLatestStatus(doc, fetcher, { signal });
    if (!latest) return null;
    statusService.updateStatusCells(latest, statusCells);
    return latest;
  };
  return { fetchLatest };
};

const STATUS_CELL_KEYS = STATUS_KEYS;

/**
 * @param {{
 *   apiBaseUrl?: string,
 *   voiceHosts?: { speak: string, speakTatami: string },
 *   deviceHosts?: Record<string, string>,
 *   maxText?: string,
 *   textUtils?: {
 *     sanitizeText: (value: unknown) => string,
 *     isTextTooLong: (value: unknown, maxText: unknown) => boolean
 *   }
 * }} [options]
 * @returns {{
 *   buildVoiceUrls: (voiceText: string) => { speak: string, speakTatami: string },
 *   updateVoiceLinks: (voiceText: string, elements: { speak: HTMLElement, speakTatami: HTMLElement }) => boolean,
 *   buildCarArrivalArgs: () => Array<string | number>
 * }}
 */
const createVoiceService = ({
  apiBaseUrl = API_BASE_URL,
  voiceHosts = VOICE_HOSTS,
  deviceHosts = DEVICE_HOSTS,
  maxText = MAX_TEXT,
  textUtils = createTextUtils(),
} = {}) => {
  const { sanitizeText, isTextTooLong } = textUtils;

  const buildVoiceUrls = (voiceText) => {
    const sanitized = sanitizeText(voiceText);
    return {
      speak: `${apiBaseUrl}/google-home-speaker-wrapper/-h/${voiceHosts.speak}/-v/60/-s/${sanitized}`,
      speakTatami: `${apiBaseUrl}/google-home-speaker-wrapper/-h/${voiceHosts.speakTatami}/-v/60/-s/${sanitized}`,
    };
  };

  const updateVoiceLinks = (voiceText, elements) => {
    if (isTextTooLong(voiceText, maxText)) {
      elements.speak.removeAttribute("data-url");
      elements.speakTatami.removeAttribute("data-url");
      return false;
    }
    const { speak, speakTatami } = buildVoiceUrls(voiceText);
    elements.speak.dataset.url = speak;
    elements.speakTatami.dataset.url = speakTatami;
    return true;
  };

  const buildCarArrivalArgs = () => [
    "google-home-speaker-wrapper",
    "-h",
    deviceHosts.nest,
    "-v",
    60,
    "-s",
    sanitizeText(CAR_ARRIVAL_MESSAGE),
  ];

  return {
    buildVoiceUrls,
    updateVoiceLinks,
    buildCarArrivalArgs,
  };
};

const defaultVoiceService = createVoiceService();

const { buildVoiceUrls, updateVoiceLinks, buildCarArrivalArgs } = defaultVoiceService;

/**
 * @param {{
 *   doc: Document,
 *   elements: { voicetext: HTMLInputElement, speak: HTMLElement, speakTatami: HTMLElement },
 *   notifier?: { reportError?: (doc: Document, message: string, details?: unknown) => void },
 *   updateVoiceLinks?: (voiceText: string, elements: { speak: HTMLElement, speakTatami: HTMLElement }) => boolean
 * }} params
 */
const createVoiceController = ({
  doc,
  elements,
  notifier,
  updateVoiceLinks: updateVoiceLinksFn = updateVoiceLinks,
} = {}) => {
  const bindInput = () => {
    elements.voicetext.addEventListener("input", () => {
      if (!updateVoiceLinksFn(elements.voicetext.value, { speak: elements.speak, speakTatami: elements.speakTatami })) {
        notifier?.reportError?.(doc, ERROR_MESSAGES.TOO_LONG, elements.voicetext.value);
      }
    });
  };
  return { bindInput };
};

/**
 * @param {{ apiBaseUrl?: string, youtubeHosts?: Set<string> }} [options]
 * @returns {{
 *   parseYouTubeId: (youtubeUrl: string) => string | null,
 *   buildYouTubePlayUrl: (host: string, youtubeUrl: string, volume?: string | number) => string | null
 * }}
 */
const createYouTubeService = ({ apiBaseUrl = API_BASE_URL, youtubeHosts = YOUTUBE_HOSTS } = {}) => {
  const parseYouTubeId = (youtubeUrl) => {
    if (!youtubeUrl) {
      return null;
    }
    try {
      const parsed = new URL(youtubeUrl);
      if (parsed.protocol !== "http:" && parsed.protocol !== "https:") {
        return null;
      }
      if (parsed.hostname === "youtu.be") {
        return parsed.pathname.split("/")[1] || null;
      }
      if (!youtubeHosts.has(parsed.hostname)) {
        return null;
      }

      const handlers = [
        {
          match: () => parsed.pathname === "/watch",
          getId: () => parsed.searchParams.get("v") || null,
        },
        {
          match: () => parsed.pathname.startsWith("/live/") || parsed.pathname.startsWith("/shorts/"),
          getId: () => parsed.pathname.split("/")[2] || null,
        },
      ];

      const handler = handlers.find(({ match }) => match());
      return handler ? handler.getId() : null;
    } catch {
      return null;
    }
  };

  const buildYouTubePlayUrl = (host, youtubeUrl, volume) => {
    const videoId = parseYouTubeId(youtubeUrl);
    if (!videoId) {
      return null;
    }
    const volumeNumber = Number(volume);
    const resolvedVolume =
      Number.isFinite(volumeNumber) && volumeNumber >= 0 && volumeNumber <= 100 ? volumeNumber : 40;
    return `${apiBaseUrl}/youtube-play/-h/${host}/-v/${resolvedVolume}/-i/${videoId}`;
  };

  return {
    parseYouTubeId,
    buildYouTubePlayUrl,
  };
};

const defaultYouTubeService = createYouTubeService();

const { parseYouTubeId, buildYouTubePlayUrl } = defaultYouTubeService;

/**
 * @param {{
 *   doc: Document,
 *   fetcher: typeof fetch,
 *   notifier?: { reportError?: (doc: Document, message: string, details?: unknown) => void },
 *   elements: { youtubeUrl?: HTMLInputElement },
 *   buildYouTubePlayUrl?: (host: string, youtubeUrl: string, volume?: string | number) => string | null
 * }} params
 */
const createYouTubeController = ({
  doc,
  fetcher,
  notifier,
  elements,
  buildYouTubePlayUrl: buildYouTubePlayUrlFn = buildYouTubePlayUrl,
} = {}) => {
  const youtubePlay = (host, volume) => {
    const { youtubeUrl } = elements;
    if (!youtubeUrl) return null;
    const playUrl = buildYouTubePlayUrlFn(host, youtubeUrl.value, volume);
    if (!playUrl) {
      if (youtubeUrl.value) notifier?.reportError?.(doc, ERROR_MESSAGES.INVALID_URL, youtubeUrl.value);
      youtubeUrl.value = "";
      return null;
    }
    return fetcher(playUrl);
  };
  return { youtubePlay };
};

const REQUIRED_IDS = ["voicetext", "speak", "speak_tatami", "hour", "min", "alarmtext", "set"];
/**
 * @param {Document} doc
 * @param {Array<string>} ids
 * @returns {Record<string, HTMLElement | null>}
 */
const getRequiredElements = (doc, ids) => Object.fromEntries(ids.map((id) => [id, doc.getElementById(id)]));

/**
 * @param {string} value
 * @returns {Array<Array<string | number>>}
 */
const parseApiCommands = (value) => {
  if (!value) return [];
  let parsed;
  try {
    parsed = JSON.parse(value);
  } catch (error) {
    console.error(ERROR_MESSAGES.PARSE_DATA_API, error);
    throw error;
  }
  if (!Array.isArray(parsed)) {
    const error = new Error(ERROR_MESSAGES.INVALID_DATA_API);
    console.error(error.message, parsed);
    throw error;
  }
  if (!parsed.length) return [];
  return parsed.every(Array.isArray) ? parsed : [parsed];
};

/**
 * @param {Document} doc
 * @returns {{
 *   hasRequired: boolean,
 *   hasStatus: boolean,
 *   requiredElements: Record<string, HTMLElement | null>,
 *   statusCells: Record<string, HTMLElement | null>,
 *   elements: {
 *     voicetext: HTMLInputElement | null,
 *     speak: HTMLElement | null,
 *     speakTatami: HTMLElement | null,
 *     hour: HTMLSelectElement | null,
 *     min: HTMLSelectElement | null,
 *     alarmtext: HTMLInputElement | null,
 *     setButton: HTMLElement | null,
 *     youtubeUrl: HTMLInputElement | null,
 *     statusCells: Record<string, HTMLElement | null>
 *   }
 * }}
 */
const createAppState = (doc) => {
  const requiredElements = getRequiredElements(doc, REQUIRED_IDS);
  const statusCells = getRequiredElements(doc, STATUS_CELL_KEYS);
  const missingRequired = Object.values(requiredElements).some((element) => !element);
  const missingStatus = Object.values(statusCells).some((element) => !element);
  const { voicetext, speak, speak_tatami: speakTatami, hour, min, alarmtext, set: setButton } = requiredElements;
  const youtubeUrl = doc.getElementById("youtube_url");
  return {
    hasRequired: !missingRequired,
    hasStatus: !missingStatus,
    requiredElements,
    statusCells,
    elements: {
      voicetext,
      speak,
      speakTatami,
      hour,
      min,
      alarmtext,
      setButton,
      youtubeUrl,
      statusCells,
    },
  };
};

/**
 * @param {Document} doc
 * @param {typeof fetch} [fetcher]
 * @returns {{
 *   setAlarm: () => Promise<boolean>,
 *   youtubePlay: (host: string, volume?: string | number) => Promise<Response> | null,
 *   fetchLatest: (signal?: AbortSignal) => Promise<Record<string, unknown> | null>,
 *   elements: ReturnType<typeof createAppState>["elements"]
 * } | null}
 */
const initApp = (doc, fetcher = fetch) => {
  const state = createAppState(doc);
  if (!state.hasRequired) return null;

  const notifier = { reportError };
  const alarmController = createAlarmController({ doc, fetcher, notifier, elements: state.elements });
  const voiceController = createVoiceController({ doc, elements: state.elements, notifier });
  const youtubeController = createYouTubeController({ doc, fetcher, notifier, elements: state.elements });
  const statusController = createStatusController({
    doc,
    fetcher,
    statusCells: state.statusCells,
    hasStatus: state.hasStatus,
  });

  alarmController.setDefaults();
  voiceController.bindInput();

  return {
    setAlarm: alarmController.setAlarm,
    youtubePlay: youtubeController.youtubePlay,
    fetchLatest: statusController.fetchLatest,
    elements: state.elements,
  };
};

/**
 * @param {Document} doc
 * @param {string} selector
 * @param {(link: HTMLAnchorElement) => Promise<void>} handler
 */
const bindLinkClicks = (doc, selector, handler) => {
  doc.querySelectorAll(selector).forEach((link) =>
    link.addEventListener("click", async (event) => {
      event.preventDefault();
      await handler(link);
    }),
  );
};

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

/**
 * @param {Document} doc
 * @param {(signal?: AbortSignal) => Promise<unknown>} fetchLatest
 * @param {{ onSchedule?: (delayMs: number) => void }} [options]
 * @returns {() => void}
 */
const scheduleLatestFetch = (doc, fetchLatest, { onSchedule } = {}) => {
  let timerId;
  let controller;
  const schedule = (delayMs) => ((timerId = setTimeout(run, delayMs)), onSchedule?.(delayMs));
  const nextDelay = (error) =>
    error?.name === "AbortError" ? STATUS_INTERVAL_MS : STATUS_INTERVAL_MS + STATUS_BACKOFF_MS;
  const run = async () => {
    controller?.abort();
    controller = new AbortController();
    try {
      await fetchLatest(controller.signal);
      schedule(STATUS_INTERVAL_MS);
    } catch (error) {
      if (error?.name !== "AbortError") reportError(doc, ERROR_MESSAGES.FETCH_STATUS, error);
      schedule(nextDelay(error));
    }
  };
  run();
  return () => clearTimeout(timerId);
};

const handleDataApi = async (doc, fetcher, dataApi) => {
  try {
    const apiCommands = parseApiCommands(dataApi);
    for (let index = 0; index < apiCommands.length; index += 1) {
      await fetcher(apiUrl(replaceHostTokens(apiCommands[index])));
      if (DATA_API_DELAY_MS > 0 && index < apiCommands.length - 1) await delay(DATA_API_DELAY_MS);
    }
  } catch (error) {
    reportError(doc, ERROR_MESSAGES.EXEC_COMMANDS, error);
  }
};

/**
 * @param {Document} doc
 * @param {typeof fetch} fetcher
 * @param {{
 *   setAlarm: () => Promise<boolean>,
 *   youtubePlay: (host: string, volume?: string | number) => Promise<Response> | null,
 *   elements: {
 *     setButton: HTMLElement,
 *     alarmtext: HTMLInputElement,
 *     youtubeUrl: HTMLInputElement,
 *     speak: HTMLElement,
 *     speakTatami: HTMLElement,
 *     voicetext: HTMLInputElement
 *   }
 * }} instance
 */
const wireEvents = (doc, fetcher, instance) => {
  const { setAlarm, elements } = instance;

  elements.setButton.addEventListener("click", async (event) => {
    event.preventDefault();
    if (await setAlarm()) elements.alarmtext.value = "";
  });

  elements.youtubeUrl.addEventListener("blur", () => {
    if (elements.youtubeUrl.value && !parseYouTubeId(elements.youtubeUrl.value)) {
      reportError(doc, ERROR_MESSAGES.INVALID_URL, elements.youtubeUrl.value);
      elements.youtubeUrl.value = "";
    }
  });

  bindLinkClicks(doc, "a[data-api], a[data-status-action], a[data-message-key]", async (link) => {
    if (link.dataset.api) await handleDataApi(doc, fetcher, link.dataset.api);
    if (link.dataset.messageKey === "car-arrival") await fetcher(apiUrl(buildCarArrivalArgs()));
    if (link.dataset.statusAction) await fetcher(buildStatusUrl({ s: "status", t: link.dataset.statusAction }));
  });

  bindLinkClicks(doc, "a[data-youtube-host], a[data-youtube-key]", async (link) => {
    const host = link.dataset.youtubeHost ?? resolveHost(link.dataset.youtubeKey);
    if (!host) return;
    const volume = link.dataset.youtubeVol;
    if (await instance.youtubePlay(host, volume)) elements.youtubeUrl.value = "";
  });

  [elements.speak, elements.speakTatami].forEach((link) => {
    link.addEventListener("click", async (event) => {
      event.preventDefault();
      if (!link.dataset.url) return;
      try {
        const response = await fetcher(link.dataset.url);
        if (response.ok) elements.voicetext.value = "";
      } catch (error) {
        reportError(doc, ERROR_MESSAGES.SEND_VOICE, error);
      }
    });
  });
};

/**
 * @param {Document} [doc]
 * @param {typeof fetch} [fetcher]
 * @returns {ReturnType<typeof initApp> | null}
 */
const start = (doc = document, fetcher = fetch) => {
  const instance = initApp(doc, fetcher);
  if (!instance) return null;
  doc.querySelectorAll("a").forEach((link) => link.setAttribute("href", "#"));
  scheduleLatestFetch(doc, instance.fetchLatest);
  wireEvents(doc, fetcher, instance);
  return instance;
};

if (typeof window !== "undefined") {
  const instance = start(document, fetch);
  window.api = (args) => {
    fetch(apiUrl(args));
  };
  window.setAlarm = () => instance?.setAlarm();
  window.youtubePlay = (host) => instance?.youtubePlay(host);
}</script>
    <div id="notification-container" aria-live="polite"></div>
  </body>
</html>
